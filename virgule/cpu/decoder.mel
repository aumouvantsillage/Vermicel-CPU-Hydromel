#lang hydromel

# This Source Code Form is subject to the terms of the Mozilla Public
# License, v. 2.0. If a copy of the MPL was not distributed with this
# file, You can obtain one at https://mozilla.org/MPL/2.0/.

import "common.mel"
import "opcodes.mel"

type register_index_t = unsigned(5)
type funct3_t         = unsigned(3)
type alu_fn_t         = unsigned(4) # TODO enumeration

# TODO remove when alu_fn_t is an enumeration
constant alu_nop  = 1
constant alu_add  = 2
constant alu_sub  = 3
constant alu_slt  = 4
constant alu_sltu = 5
constant alu_and  = 6
constant alu_or   = 7
constant alu_xor  = 8
constant alu_sll  = 9
constant alu_srl  = 10
constant alu_sra  = 11

type instruction_t = record(
    rd        : register_index_t,
    rs1       : register_index_t,
    rs2       : register_index_t,
    imm       : signed_word_t,
    funct3    : funct3_t,
    alu_fn    : alu_fn_t,
    use_pc    : bit,
    use_imm   : bit,
    has_rd    : bit,
    is_load   : bit,
    is_store  : bit,
    is_jump   : bit,
    is_branch : bit,
    is_mret   : bit,
)

constant instr_nop = (
    rd        => 0,
    rs1       => 0,
    rs2       => 0,
    imm       => 0,
    funct3    => funct3_add_sub,
    alu_fn    => alu_nop,
    use_pc    => 0,
    use_imm   => 0,
    has_rd    => 0,
    is_load   => 0,
    is_store  => 0,
    is_jump   => 0,
    is_branch => 0,
    is_mret   => 0,
)

component decoder
    port data  : in word_t
    port instr : out instruction_t

    signal funct7 = data{31..25}
    signal rs2    = data{24..20}
    signal rs1    = data{19..15}
    signal funct3 = data{14..12}
    signal rd     = data{11.. 7}
    signal opcode = data{ 6.. 0}

    signal imm = case opcode of
        opcode_op                => 0
        opcode_store             => {funct7, rd} as integer
        opcode_branch            => {data{31}, data{7}, data{30..25}, data{11..8}, 0} as integer
        opcode_lui, opcode_auipc => ({funct7, rs2, rs1, funct3} << 12) as integer
        opcode_jal               => {data{31}, rs1, funct3, data{20}, data{30..21}, 0} as integer
        _                        => {funct7, rs2} as integer

    signal alu_fn = case opcode of
        opcode_lui => alu_nop
        opcode_op, opcode_op_imm => (
            case funct3 of
                funct3_slt  => alu_slt
                funct3_sltu => alu_sltu
                funct3_and  => alu_and
                funct3_or   => alu_or
                funct3_xor  => alu_xor
                funct3_sll  => alu_sll
                funct3_srl_sra =>
                    if funct7 == funct7_sub_sra then
                        alu_sra
                    else
                        alu_srl
                funct3_add_sub =>
                    if opcode == opcode_op and funct7 == funct7_sub_sra then
                        alu_sub
                    else
                        alu_add
                _ => alu_add
            )
        _ => alu_add

    instr = (
        rd        => rd,
        rs1       => rs1,
        rs2       => rs2,
        imm       => imm,
        funct3    => funct3,
        alu_fn    => alu_fn,
        use_pc    => opcode == opcode_auipc or opcode == opcode_jal or opcode == opcode_branch,
        use_imm   => opcode /= opcode_op,
        is_load   => opcode == opcode_load,
        is_store  => opcode == opcode_store,
        is_mret   => opcode == opcode_system and funct3 == funct3_mret and imm == imm_mret,
        is_jump   => opcode == opcode_jal or opcode == opcode_jalr,
        is_branch => opcode == opcode_branch,
        has_rd    => not (opcode == opcode_branch or opcode == opcode_store or rd == 0),
    )
end
